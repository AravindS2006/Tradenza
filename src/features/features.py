import pandas as pd
import numpy as np
import ta
import yaml
from typing import List
from sklearn.preprocessing import StandardScaler, MinMaxScaler

class FeatureEngineer:
    """
    Generates technical indicators and normalizes features for RL input.
    """
    def __init__(self, config_path: str = "config/config.yaml"):
        with open(config_path, 'r') as file:
            self.config = yaml.safe_load(file)
        
        self.feature_config = self.config['features']
        self.scaler = StandardScaler() if self.feature_config['use_scaling'] else None
        self.feature_columns = []

    def add_technical_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Calculate and append technical indicators to the DataFrame.
        
        Args:
            df (pd.DataFrame): Data with OHLCV.
            
        Returns:
            pd.DataFrame: Data with added features.
        """
        df = df.copy()
        
        # RSI
        df['rsi'] = ta.momentum.RSIIndicator(
            close=df['close'], window=self.feature_config['rsi_period']
        ).rsi()
        
        # MACD
        macd = ta.trend.MACD(
            close=df['close'],
            window_slow=self.feature_config['macd_slow'],
            window_fast=self.feature_config['macd_fast'],
            window_sign=self.feature_config['macd_signal']
        )
        df['macd'] = macd.macd()
        df['macd_signal'] = macd.macd_signal()
        df['macd_diff'] = macd.macd_diff()
        
        # Bollinger Bands
        bb = ta.volatility.BollingerBands(
            close=df['close'],
            window=self.feature_config['bb_period'],
            window_dev=self.feature_config['bb_std']
        )
        df['bb_high'] = bb.bollinger_hband()
        df['bb_low'] = bb.bollinger_lband()
        df['bb_width'] = bb.bollinger_wband()
        
        # ATR (Average True Range) for volatility
        # Using a potentially smoother ATR for RL stability
        df['atr'] = ta.volatility.AverageTrueRange(
            high=df['high'], low=df['low'], close=df['close'],
            window=self.feature_config.get('atr_period', 14)
        ).average_true_range()
        
        # DXY Correlation Placeholder
        # The Meta-Optimizer requires DXY correlation in the state space.
        # Since we lack external DXY data, we initialize this feature as 0.0
        # or use a proxy (e.g. correlation with USD volume if available, or just noise).
        # ideally this would load 'dxy.csv' and merge.
        if 'dxy_close' not in df.columns:
            df['dxy_corr'] = 0.0 # Placeholder
        else:
             # Calculate rolling correlation if DXY data existed
             df['dxy_corr'] = df['close'].rolling(window=30).corr(df['dxy_close'])
        
        # Lagged Returns (Log returns)
        df['log_ret'] = np.log(df['close'] / df['close'].shift(1))
        
        for lag in self.feature_config['lag_periods']:
            df[f'log_ret_lag_{lag}'] = df['log_ret'].shift(lag)
            
        # Drop NaN values generated by indicators and lags
        df.dropna(inplace=True)
        
        # Update feature columns tracking (excluding original OHLCV if desired, 
        # but usually we keep them or specific ones for the state)
        # For RL state, we usually want stationary features. 
        # We'll use the indicators + returns.
        base_features = ['rsi', 'macd', 'macd_signal', 'macd_diff', 
                         'bb_width', 'atr', 'dxy_corr']
        lag_features = [f'log_ret_lag_{lag}' for lag in self.feature_config['lag_periods']]
        
        self.feature_columns = base_features + lag_features + ['log_ret']
        
        return df

    def fit_scaler(self, train_df: pd.DataFrame):
        """
        Fit the scaler on the training data.
        """
        if self.scaler:
            self.scaler.fit(train_df[self.feature_columns])

    def transform(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Apply normalization to the features using the fitted scaler.
        
        Args:
            df (pd.DataFrame): Data to transform.
            
        Returns:
            pd.DataFrame: Scaled data.
        """
        if self.scaler:
            df_scaled = df.copy()
            df_scaled[self.feature_columns] = self.scaler.transform(df[self.feature_columns])
            return df_scaled
        return df
